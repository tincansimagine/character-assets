// @ts-nocheck
/// <reference types="jquery" />
/// <reference types="toastr" />

// import { $, toastr } from "../../../../script.js"; // 에러 발생으로 주석 처리

import { callPopup, characters, eventSource, event_types, getCurrentChatId, getRequestHeaders, reloadCurrentChat, saveSettingsDebounced, substituteParams, this_chid } from "../../../../script.js";
import { extension_settings, getContext, renderExtensionTemplateAsync, doExtrasFetch, getApiUrl, writeExtensionField } from "../../../extensions.js";
import { selected_group } from "../../../group-chats.js";
import { regex_placement, runRegexScript } from "../../regex/engine.js";
import { isTrueBoolean, download, uuidv4, getFileText, getCharaFilename } from "../../../utils.js";
import { ARGUMENT_TYPE, SlashCommandArgument, SlashCommandNamedArgument } from "../../../slash-commands/SlashCommandArgument.js";
import { SlashCommandParser } from "../../../slash-commands/SlashCommandParser.js";
import { SlashCommand } from "../../../slash-commands/SlashCommand.js";
import { t } from "../../../i18n.js";
import { MacrosParser } from "../../../../scripts/macros.js";

/**
 * 모듈 이름 상수
 */
const MODULE_NAME = 'character-assets';

/**
 * 정규식 확장 기능 관련 상수
 */
const REGEX_EXTENSION_NAME = 'regex';
const REGEX_SCRIPTS_FIELD = 'scripts';
const BASE_REGEX_FILE = `/scripts/extensions/third-party/${MODULE_NAME}/character-assets_0.json`;

/**
 * 확장자 목록
 */
const ALLOWED_EXTENSIONS = ['png', 'webp', 'gif', 'jpg', 'jpeg'];

/**
 * 자동 갱신된 키워드를 저장하는 전역 변수
 */
let autoGeneratedKeywords = '';

/**
 * 기본 이미지 출력 프롬프트
 */
const DEFAULT_IMAGE_PROMPT = `### Prompt Instruction for Image Tag Insertion (Custom Format Version)

When processing the text, insert up to 2 internal image tags per response, placed between paragraphs (i.e., after a full paragraph has ended). Follow these guidelines precisely:

1. Tag Format:
   Always use the format \`{{img::keyword.extension}}\` — this is a custom tag format used specifically for internal assets.
   - You must include the correct file extension (e.g., \`.jpg\`, \`.png\`, \`.webp\`, etc.) as part of the filename.
   - Do NOT use standard HTML tags like \`<img src="...">\` — those are reserved for external images.
   - Example (correct): \`{{img::steampunk_city.jpg}}\`
   - Incorrect: \`<img src="steampunk_city.jpg">\`

2. Placement Limitation:
   - Insert no more than 2 image tags per response.
   - Insert only if the image enhances the reader's understanding, mood, or emotional tone of the paragraph.
   - Each tag must be placed after a full paragraph ends, not mid-sentence.

3. Context Matching:
   Evaluate the content of each paragraph.
   If a keyword from the list clearly matches the subject, tone, or setting, insert the corresponding image tag after that paragraph.
   - If no keyword fits the context, skip insertion.

4. Avoiding Repetition:
   - Do not repeat the same keyword multiple times across recent responses.
   - Rotate and diversify your choices whenever possible.

5. Syntax Handling:
   This system does not support HTML \`<img>\` tags for internal image rendering.
   Only use \`{{img::filename.ext}}\` format for internal images.
   External images (e.g., from \`https://\` URLs) must continue to use \`<img src="...">\`.

6. Keyword List:
The available keywords (with extensions) are: \`{{img_keywords_autogen}}\`
- Use only the exact filenames and extensions from the list.
- Do not guess, invent, or modify extensions or filenames.
`;

/**
 * 기본 프리셋 이름
 */
const DEFAULT_PRESET_NAME = '기본 프리셋';

/**
 * 정규식 기본값
 */
const DEFAULT_REGEX_FIND = '(?<!\\\\)!\\[([^\\[\\]]+)\\]\\(([^\\(\\)]+)\\)';
const DEFAULT_REGEX_REPLACE = '<div style="display:inline-block; text-align:center; margin: 5px 0;"><img onerror="this.src=\\\'../img/notfound.webp\\\'" class="character_asset" src="$2" /><br /><span style="font-size: 0.8em; opacity: 0.5;">$1</span></div>';

/**
 * 이미지 스타일 템플릿
 */
const IMAGE_STYLE_TEMPLATES = [
    {
        id: 'default',
        name: '기본 스타일 (둥근 사각형)',
        find: '/\\{\\{img::(.*?)\\}\\}/gi',
        replace: `<style>
    .imageWrapper {
      display: grid;
      place-items: center;
      width: 100%;
      padding: 1rem;
    }

    .characterImage {
      max-width: 400px;
      max-height: 800px;
      width: auto;
      height: auto;
      object-fit: contain;
      border-radius: 1rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
  </style>

  <div class="imageWrapper">
    <img class="characterImage" src="/characters/{{charkey}}/$1">
  </div>`
    },
    {
        id: 'border',
        name: '테두리 강조형',
        find: '/\\{\\{img::(.*?)\\}\\}/gi',
        replace: `<style>
    .imageWrapper-border {
      display: grid;
      place-items: center;
      width: 100%;
      padding: 1rem;
    }

    .characterImage-border {
      max-width: 400px;
      max-height: 800px;
      width: auto;
      height: auto;
      object-fit: contain;
      border: 3px solid var(--SmartThemeBorderColor, #ccc);
      border-radius: 0.5rem;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      background: var(--SmartThemeBlurTintColor, #fff);
      padding: 0.5rem;
    }
  </style>

  <div class="imageWrapper-border">
    <img class="characterImage-border" src="/characters/{{charkey}}/$1">
  </div>`
    },
    {
        id: 'clean',
        name: '투명 배경 (깔끔한 형태)',
        find: '/\\{\\{img::(.*?)\\}\\}/gi',
        replace: `<style>
    .imageWrapper-clean {
      display: grid;
      place-items: center;
      width: 100%;
      padding: 1rem;
    }

    .characterImage-clean {
      max-width: 400px;
      max-height: 800px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
    }
  </style>

  <div class="imageWrapper-clean">
    <img class="characterImage-clean" src="/characters/{{charkey}}/$1">
  </div>`
    },
    {
        id: 'shadow',
        name: '그림자 강조형',
        find: '/\\{\\{img::(.*?)\\}\\}/gi',
        replace: `<style>
    .imageWrapper-shadow {
      display: grid;
      place-items: center;
      width: 100%;
      padding: 1.5rem;
    }

    .characterImage-shadow {
      max-width: 400px;
      max-height: 800px;
      width: auto;
      height: auto;
      object-fit: contain;
      border-radius: 0.75rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3),
                  0 1px 2px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .characterImage-shadow:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.35),
                  0 1px 3px rgba(0, 0, 0, 0.25);
    }
  </style>

  <div class="imageWrapper-shadow">
    <img class="characterImage-shadow" src="/characters/{{charkey}}/$1">
  </div>`
    },
    {
        id: 'polaroid',
        name: '폴라로이드형',
        find: '/\\{\\{img::(.*?)\\}\\}/gi',
        replace: `<style>
    .imageWrapper-polaroid {
      display: grid;
      place-items: center;
      width: 100%;
      padding: 1rem;
    }

    .polaroid-frame {
      background: #f8f8f8;
      padding: 0.75rem 0.75rem 3rem 0.75rem;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transform: rotate(-2deg);
      transition: transform 0.2s ease;
    }

    .polaroid-frame:hover {
      transform: rotate(0deg);
    }

    .characterImage-polaroid {
      max-width: 350px;
      max-height: 500px;
      width: auto;
      height: auto;
      object-fit: contain;
      display: block;
    }
  </style>

  <div class="imageWrapper-polaroid">
    <div class="polaroid-frame">
      <img class="characterImage-polaroid" src="/characters/{{charkey}}/$1">
    </div>
  </div>`
    }
];

/**
 * 에셋 인터페이스 정의
 * @typedef {Object} Asset
 * @property {string} path - 에셋 경로
 * @property {string} label - 에셋 라벨(키워드)
 */

/**
 * 확장 설정 초기화
 */
function initializeSettings() {
    if (!extension_settings[MODULE_NAME]) {
        extension_settings[MODULE_NAME] = {};
    }

    if (!extension_settings[MODULE_NAME].characterAssets) {
        extension_settings[MODULE_NAME].characterAssets = {};
    }

    if (!extension_settings[MODULE_NAME].imagePrompt) {
        extension_settings[MODULE_NAME].imagePrompt = DEFAULT_IMAGE_PROMPT;
    }

    // 프리셋 데이터 초기화
    if (!extension_settings[MODULE_NAME].presets) {
        extension_settings[MODULE_NAME].presets = [
            {
                id: uuidv4(),
                name: DEFAULT_PRESET_NAME,
                prompt: DEFAULT_IMAGE_PROMPT
            }
        ];
        extension_settings[MODULE_NAME].currentPresetId = extension_settings[MODULE_NAME].presets[0].id;
    }

    if (typeof extension_settings[MODULE_NAME].enabled === 'undefined') {
        extension_settings[MODULE_NAME].enabled = true;
    }
}

/**
 * 현재 선택된 캐릭터 정보를 가져옴
 * @returns {object} 캐릭터 정보
 */
function getCurrentCharacter() {
    const context = getContext();
    if (selected_group) {
        return null; // 그룹은 아직 지원하지 않음
    }
    return characters[this_chid];
}

/**
 * 캐릭터의 에셋 정보 초기화
 * @param {string} characterId 캐릭터 ID
 */
function initializeCharacterAssets(characterId) {
    if (!extension_settings[MODULE_NAME].characterAssets[characterId]) {
        extension_settings[MODULE_NAME].characterAssets[characterId] = {
            enabled: true,
            imageKeywords: [],
            regexFind: DEFAULT_REGEX_FIND,
            regexReplace: DEFAULT_REGEX_REPLACE,
            regexOptions: {
                userInput: false,
                aiOutput: true,
                runOnEdit: true,
                onlyFormatDisplay: true
            }
        };
    } else if (!extension_settings[MODULE_NAME].characterAssets[characterId].regexOptions) {
        // 기존 설정에 regexOptions가 없으면 추가
        extension_settings[MODULE_NAME].characterAssets[characterId].regexOptions = {
            userInput: false,
            aiOutput: true,
            runOnEdit: true,
            onlyFormatDisplay: true
        };
    }
}

/**
 * 에셋 정보 가져오기
 * @param {string} characterId 캐릭터 ID
 * @returns {object} 에셋 정보
 */
function getCharacterAssets(characterId) {
    initializeCharacterAssets(characterId);
    return extension_settings[MODULE_NAME].characterAssets[characterId];
}

/**
 * 플레이스홀더 교체
 * @param {string} text 입력 텍스트
 * @param {string} characterId 캐릭터 ID
 * @returns {string} 처리된 텍스트
 */
function replacePlaceholders(text, characterId) {
    const assets = getCharacterAssets(characterId);
    let result = text;

    // {{img_keywords}} 플레이스홀더 교체 (캐릭터별 설정값 사용)
    if (assets && Array.isArray(assets.imageKeywords)) {
        const keywordsList = assets.imageKeywords.join(', ');
        result = result.replace(/\{\{img_keywords\}\}/g, keywordsList);
    }

    // {{img_inprompt}} 플레이스홀더 교체 (이미지 출력 프롬프트 전체로 교체)
    if (extension_settings[MODULE_NAME].imagePrompt) {
        result = result.replace(/\{\{img_inprompt\}\}/g, extension_settings[MODULE_NAME].imagePrompt);
    }

    return result;
}

/**
 * 캐릭터 에셋 확장 활성화 여부 확인
 * @param {string} characterId 캐릭터 ID
 * @returns {boolean} 활성화 여부
 */
function isCharacterAssetsEnabled(characterId) {
    return true;
}

/**
 * 현재 선택된 프리셋 ID를 가져옵니다.
 * @returns {string} 프리셋 ID
 */
function getCurrentPresetId() {
    return extension_settings[MODULE_NAME].currentPresetId;
}

/**
 * 현재 선택된 프리셋 객체를 가져옵니다.
 * @returns {Object|null} 프리셋 객체 또는 null
 */
function getCurrentPreset() {
    const presetId = getCurrentPresetId();
    return getPresetById(presetId);
}

/**
 * ID로 프리셋을 찾습니다.
 * @param {string} presetId 프리셋 ID
 * @returns {Object|null} 프리셋 객체 또는 null
 */
function getPresetById(presetId) {
    const presets = extension_settings[MODULE_NAME].presets || [];
    return presets.find(preset => preset.id === presetId) || null;
}

/**
 * 이름으로 프리셋을 찾습니다.
 * @param {string} name 프리셋 이름
 * @returns {Object|null} 프리셋 객체 또는 null
 */
function getPresetByName(name) {
    const presets = extension_settings[MODULE_NAME].presets || [];
    return presets.find(preset => preset.name === name) || null;
}

/**
 * 사용자가 선택한 프리셋 ID를 저장합니다.
 * @param {string} presetId 프리셋 ID
 */
function selectPreset(presetId) {
    const preset = getPresetById(presetId);
    if (preset) {
        extension_settings[MODULE_NAME].currentPresetId = presetId;
        extension_settings[MODULE_NAME].imagePrompt = preset.prompt;
        saveSettingsDebounced();
        updateInterface();
    }
}

/**
 * 현재 에디터의 프롬프트를 선택된 프리셋에 저장합니다.
 */
function saveCurrentPromptToPreset() {
    const preset = getCurrentPreset();
    if (preset) {
        const currentPrompt = $('#character_assets_image_prompt').val();
        preset.prompt = currentPrompt;
        extension_settings[MODULE_NAME].imagePrompt = currentPrompt;
        saveSettingsDebounced();
        showToast('success', `"${preset.name}" 프리셋에 프롬프트가 저장되었습니다.`);
    }
}

/**
 * 새 프리셋을 생성합니다.
 * @param {string} name 새 프리셋 이름
 * @returns {Object} 생성된 프리셋 객체
 */
async function createPreset(name) {
    const presets = extension_settings[MODULE_NAME].presets || [];

    // 중복 이름 체크
    let uniqueName = name;
    let counter = 1;
    while (getPresetByName(uniqueName)) {
        uniqueName = `${name} (${counter})`;
        counter++;
    }

    const currentPrompt = $('#character_assets_image_prompt').val();
    const newPreset = {
        id: uuidv4(),
        name: uniqueName,
        prompt: currentPrompt
    };

    presets.push(newPreset);
    extension_settings[MODULE_NAME].presets = presets;
    extension_settings[MODULE_NAME].currentPresetId = newPreset.id;
    saveSettingsDebounced();

    return newPreset;
}

/**
 * 프리셋 이름을 변경합니다.
 * @param {string} presetId 프리셋 ID
 * @param {string} newName 새 이름
 * @returns {boolean} 성공 여부
 */
function renamePreset(presetId, newName) {
    const preset = getPresetById(presetId);
    if (!preset) return false;

    // 기본 프리셋은 이름 변경 불가
    if (preset.name === DEFAULT_PRESET_NAME) {
        showToast('error', '기본 프리셋의 이름은 변경할 수 없습니다.');
        return false;
    }

    // 중복 이름 체크
    if (getPresetByName(newName)) {
        showToast('error', `"${newName}" 이름의 프리셋이 이미 존재합니다.`);
        return false;
    }

    preset.name = newName;
    saveSettingsDebounced();

    return true;
}

/**
 * 프리셋을 삭제합니다.
 * @param {string} presetId 삭제할 프리셋 ID
 * @returns {boolean} 성공 여부
 */
function deletePreset(presetId) {
    const presets = extension_settings[MODULE_NAME].presets || [];
    const presetIndex = presets.findIndex(preset => preset.id === presetId);

    if (presetIndex === -1) return false;

    // 기본 프리셋은 삭제 불가
    if (presets[presetIndex].name === DEFAULT_PRESET_NAME) {
        showToast('error', '기본 프리셋은 삭제할 수 없습니다.');
        return false;
    }

    // 마지막 프리셋은 삭제 불가
    if (presets.length <= 1) {
        showToast('error', '마지막 프리셋은 삭제할 수 없습니다.');
        return false;
    }

    // 현재 선택된 프리셋이 삭제되는 경우, 기본 프리셋으로 전환
    if (extension_settings[MODULE_NAME].currentPresetId === presetId) {
        const defaultPreset = presets.find(p => p.name === DEFAULT_PRESET_NAME) || presets[0];
        extension_settings[MODULE_NAME].currentPresetId = defaultPreset.id;
        extension_settings[MODULE_NAME].imagePrompt = defaultPreset.prompt;
    }

    // 프리셋 삭제
    presets.splice(presetIndex, 1);
    saveSettingsDebounced();

    return true;
}

/**
 * 프리셋 목록을 UI에 업데이트합니다.
 */
function updatePresetUI() {
    const presets = extension_settings[MODULE_NAME].presets || [];
    const currentPresetId = getCurrentPresetId();
    const $selector = $('#prompt_preset_selector');

    // 이전 옵션 제거
    $selector.empty();

    // 프리셋 옵션 추가
    presets.forEach(preset => {
        const $option = $('<option></option>')
            .val(preset.id)
            .text(preset.name)
            .prop('selected', preset.id === currentPresetId);
        $selector.append($option);
    });
}

/**
 * 정규식 스크립트 생성/업데이트 (이제 사용 안함, 참조용)
 * @param {string} characterId 캐릭터 ID
 */
async function createOrUpdateRegexScript(characterId) {
    // 이 함수는 이제 버튼 클릭으로 직접 호출되지 않습니다.
    // 참조용 또는 다른 로직에서 재사용될 경우를 위해 남겨둡니다.
    // ... (이전 함수 내용) ...
}

/**
 * 캐릭터 에셋을 불러옴
 * @param {string} characterName 캐릭터 이름
 * @returns {Promise<Asset[]>} 에셋 경로 목록
 */
async function fetchCharacterAssets(characterName) {
    try {
        const result = await fetch(`/api/sprites/get?name=${encodeURIComponent(characterName)}`);
        if (!result.ok) {
            return [];
        }
        const data = await result.json();
        return data;
    } catch (error) {
        console.error(`[${MODULE_NAME}] Error fetching assets:`, error);
        return [];
    }
}

/**
 * 에셋 파일명에서 키워드 추출
 * @param {string} fileName 파일명
 * @returns {string} 키워드
 */
function extractKeywordFromFileName(fileName) {
    // 확장자 제거
    return fileName.split('.').slice(0, -1).join('.');
}

/**
 * 캐릭터가 변경되었을 때 호출되는 함수
 */
async function onCharacterChanged() {
    const character = getCurrentCharacter();
    if (!character) {
        // 캐릭터가 없을 때도 키워드 초기화
        autoGeneratedKeywords = '';
        return;
    }

    initializeCharacterAssets(String(this_chid));
    updateInterface();
    await loadCharacterAssets();
}

/**
 * 캐릭터의 에셋 로드
 */
async function loadCharacterAssets() {
    const character = getCurrentCharacter();
    if (!character) {
        return;
    }

    const assets = await fetchCharacterAssets(character.avatar.replace(/\.[^/.]+$/, ''));
    const assetsListContainer = $('#character_assets_list');
    assetsListContainer.empty();

    if (assets.length === 0) {
        assetsListContainer.append('<div class="no_assets_message">캐릭터에 연결된 에셋이 없습니다. 에셋을 추가하세요.</div>');
        // 전체 선택 체크박스 비활성화
        $('#select_all_keywords').prop('checked', false).prop('disabled', true);
        $('#delete_selected_keywords').prop('disabled', true);

        // 키워드 자동 갱신 - 빈 배열
        await refreshImageKeywordsAuto();
        return;
    }

    // 전체 선택 및 삭제 버튼 활성화
    $('#select_all_keywords').prop('disabled', false);
    $('#delete_selected_keywords').prop('disabled', false);

    // 키워드별로 에셋 그룹화
    const keywordMap = {};
    assets.forEach(asset => {
        const keyword = asset.label;
        const fullFileNameWithQuery = asset.path.split('/').pop();
        const fileName = fullFileNameWithQuery.split('?')[0];
        if (!keywordMap[keyword]) {
            keywordMap[keyword] = [];
        }
        keywordMap[keyword].push({ fileName: fileName, path: asset.path });
    });

    // 키워드별로 UI 생성
    Object.keys(keywordMap).sort().forEach(keyword => {
        const files = keywordMap[keyword];
        const keywordGroup = $(`
            <div class="keyword-group">
                <div class="keyword-header">
                    <label class="checkbox flex-container flex1">
                        <input type="checkbox" class="keyword-checkbox" data-keyword="${keyword}">
                        <span class="keyword-name">${keyword}</span>
                    </label>
                    <!-- <span class="file-count">(${files.length}개)</span> -->
                </div>
                <div class="file-list"></div>
            </div>
        `);
        const fileListContainer = keywordGroup.find('.file-list');
        files.forEach(file => {
            const fileItem = $(`
                <div class="file-item">
                    <span class="file-name" title="${file.fileName}">${file.fileName}</span>
                    <i class="fa-solid fa-trash delete-asset-button" data-keyword="${keyword}" data-filename="${file.fileName}" title="삭제"></i>
                </div>
            `);
            fileListContainer.append(fileItem);
        });
        assetsListContainer.append(keywordGroup);
    });

    // 삭제 버튼 이벤트 핸들러 연결
    assetsListContainer.off('click', '.delete-asset-button').on('click', '.delete-asset-button', async function() {
        const keyword = $(this).data('keyword');
        const fileName = $(this).data('filename');
        const confirmDelete = await callPopup(`정말로 '${fileName}' 파일을 삭제하시겠습니까?`, 'confirm', undefined, { okButton: '삭제' });
        if (confirmDelete === true) {
            await handleDeleteAsset(keyword, fileName);
        }
    });

    // 키워드 체크박스 변경 시 '전체 선택' 체크박스 상태 업데이트
    assetsListContainer.off('change', '.keyword-checkbox').on('change', '.keyword-checkbox', function() {
        const totalCheckboxes = $('.keyword-checkbox').length;
        const checkedCheckboxes = $('.keyword-checkbox:checked').length;
        $('#select_all_keywords').prop('checked', totalCheckboxes === checkedCheckboxes);
    });

    // '전체 선택' 체크박스 변경 시 모든 키워드 체크박스 상태 변경
    // (이 핸들러는 setupEventHandlers에 있어야 할 수도 있음 - 한 번만 등록)
    //$('#select_all_keywords').off('change').on('change', function() {
    //    $('.keyword-checkbox').prop('checked', $(this).prop('checked'));
    //});

    // '선택 삭제' 버튼 이벤트 핸들러 연결
    // (이 핸들러는 setupEventHandlers에 있어야 할 수도 있음 - 한 번만 등록)
    // $('#delete_selected_keywords').off('click').on('click', async function() {
    //     // ... 삭제 로직 ...
    // });

    // 초기 전체 선택 상태 설정
    $('#select_all_keywords').prop('checked', false);

    // 키워드 자동 갱신
    await refreshImageKeywordsAuto();
}

/**
 * 이미지 키워드를 자동으로 갱신하여 img_keywords_autogen 변수에 저장
 * @returns {Promise<string>} 갱신된 키워드 문자열
 */
async function refreshImageKeywordsAuto() {
    try {
        const character = getCurrentCharacter();
        if (!character) {
            // 캐릭터가 없으면 빈 문자열 설정
            autoGeneratedKeywords = '';
            return '';
        }

        // 현재 캐릭터의 에셋 가져오기
        const assets = await fetchCharacterAssets(character.avatar.replace(/\.[^/.]+$/, ''));

        // 파일명 목록 생성 (중복 제거)
        const fileNames = new Set();
        assets.forEach(asset => {
            const fullFileNameWithQuery = asset.path.split('/').pop();
            const fileName = fullFileNameWithQuery.split('?')[0];
            fileNames.add(fileName);
        });

        // 배열로 변환하고 정렬
        const sortedFileNames = Array.from(fileNames).sort();
        const keywordString = sortedFileNames.join(', ');

        // 전역 변수에 저장
        autoGeneratedKeywords = keywordString;
        console.debug(`[${MODULE_NAME}] 이미지 키워드 자동 갱신 완료:`, keywordString);

        return keywordString;
    } catch (error) {
        console.error(`[${MODULE_NAME}] 이미지 키워드 자동 갱신 중 오류:`, error);
        autoGeneratedKeywords = '';
        return '';
    }
}

/**
 * 수동으로 이미지 키워드를 갱신하는 슬래시 명령어 콜백
 */
async function refreshImageKeywordsCommand() {
    const keywordString = await refreshImageKeywordsAuto();
    if (keywordString) {
        showToast('success', `이미지 키워드가 갱신되었습니다: ${keywordString.substring(0, 100)}${keywordString.length > 100 ? '...' : ''}`);
    } else {
        showToast('info', '이미지 키워드가 비어있습니다.');
    }
    return '';
}

/**
 * 개별 에셋 파일 삭제
 * @param {string} keyword 삭제할 파일의 키워드 (label)
 * @param {string} fileName 삭제할 파일명 (확장자 포함)
 */
async function handleDeleteAsset(keyword, fileName) {
    const character = getCurrentCharacter();
    if (!character) {
        showToast('error', '캐릭터가 선택되지 않았습니다.');
        return;
    }

    const characterName = character.avatar.replace(/\.[^/.]+$/, '');
    // spriteName은 확장자를 제외한 파일명이어야 함
    const spriteName = fileName.split('.').slice(0, -1).join('.');

    try {
        const response = await jQuery.ajax({
            type: 'POST',
            url: '/api/sprites/delete',
            data: JSON.stringify({
                name: characterName, // 캐릭터 이름
                label: keyword,      // 키워드 (label)
                spriteName: spriteName // 확장자 제외 파일명 (spriteName)
            }),
            contentType: 'application/json',
            cache: false
        });

        showToast('success', `'${fileName}' 파일이 삭제되었습니다.`);
        await loadCharacterAssets(); // 목록 새로고침
        await refreshImageKeywordsAuto(); // 키워드 자동 갱신

    } catch (error) {
        console.error(`[${MODULE_NAME}] Error deleting asset:`, error);
        const errorText = error.responseText || '알 수 없는 오류';
        showToast('error', `파일 삭제 중 오류 발생: ${errorText}`, '삭제 실패');
    }
}

/**
 * 인터페이스 업데이트
 */
function updateInterface() {
    const character = getCurrentCharacter();
    if (!character) {
        return;
    }

    const assets = getCharacterAssets(String(this_chid));

    // 정규식 설정 업데이트
    $('#character_assets_regex_find').val(assets.regexFind || DEFAULT_REGEX_FIND);
    $('#character_assets_regex_replace').val(assets.regexReplace || DEFAULT_REGEX_REPLACE);

    // 정규식 옵션 체크박스 업데이트
    const regexOptions = assets.regexOptions || {
        userInput: false,
        aiOutput: true,
        runOnEdit: true,
        onlyFormatDisplay: true
    };

    $('#regex_user_input').prop('checked', regexOptions.userInput);
    $('#regex_ai_output').prop('checked', regexOptions.aiOutput);
    $('#regex_run_on_edit').prop('checked', regexOptions.runOnEdit);
    $('#regex_only_format_display').prop('checked', regexOptions.onlyFormatDisplay);

    // 전역 이미지 프롬프트 업데이트
    $('#character_assets_image_prompt').val(extension_settings[MODULE_NAME].imagePrompt || DEFAULT_IMAGE_PROMPT);

    // 프리셋 UI 업데이트
    updatePresetUI();
}

// 페이지에 toastr 라이브러리가 로드되었는지 확인하는 헬퍼 함수
function showToast(type, message, title = '', options = {}) {
    // toastr 객체가 있는지 확인
    if (typeof toastr !== 'undefined') {
        // 기본 옵션 설정
        const defaultOptions = { timeOut: 3000, extendedTimeOut: 1000 };
        const mergedOptions = { ...defaultOptions, ...options };

        // 타입에 따라 토스트 표시
        switch (type) {
            case 'error':
                toastr.error(message, title, mergedOptions);
                break;
            case 'success':
                toastr.success(message, title, mergedOptions);
                break;
            case 'warning':
                toastr.warning(message, title, mergedOptions);
                break;
            case 'info':
                toastr.info(message, title, mergedOptions);
                break;
            default:
                console.log(message); // 폴백으로 콘솔에 출력
        }
    } else {
        // toastr이 없으면 콘솔에 출력
        console.log(`[${type.toUpperCase()}] ${title ? title + ': ' : ''}${message}`);
    }

    // 후처리를 위해 토스트 ID를 반환 (toastr이 있는 경우만)
    return typeof toastr !== 'undefined' ? toastr : null;
}

/**
 * ZIP 파일 업로드 처리
 * @param {File} file ZIP 파일
 */
async function handleZipUpload(file) {
    const character = getCurrentCharacter();
    if (!character) {
        showToast('error', '선택된 캐릭터가 없습니다.');
        return;
    }

    const formData = new FormData();
    formData.append('name', character.avatar.replace(/\.[^/.]+$/, ''));
    formData.append('avatar', file);

    const uploadToast = showToast('info', '업로드 중...', '처리 중입니다', { timeOut: 0, extendedTimeOut: 0 });

    try {
        // jQuery.ajax 사용 및 headers 제거
        const result = await jQuery.ajax({
            type: 'POST',
            url: '/api/sprites/upload-zip',
            data: formData,
            processData: false,
            contentType: false,
            cache: false
        });

        if (uploadToast) uploadToast.clear();
        showToast('success', `${result.count}개의 이미지가 업로드되었습니다.`, '업로드 성공');

        // 새로 업로드된 에셋 로드 및 자동 선택
        const assets = await fetchCharacterAssets(character.avatar.replace(/\.[^/.]+$/, ''));

        // 기존 이미지 키워드 목록 가져오기
        const characterAssets = getCharacterAssets(String(this_chid));
        const existingKeywords = characterAssets.imageKeywords || [];

        // 새 키워드 추출
        const newKeywords = new Set();
        assets.forEach(asset => {
            newKeywords.add(asset.label);
        });

        // 기존 키워드에 새 키워드 추가 (중복 방지)
        const updatedKeywords = [...existingKeywords];

        for (const keyword of newKeywords) {
            if (!existingKeywords.includes(keyword)) {
                updatedKeywords.push(keyword);
            }
        }

        // 새 키워드 목록 저장
        characterAssets.imageKeywords = updatedKeywords;
        saveSettingsDebounced();

        // UI 새로고침
        await loadCharacterAssets();
        await refreshImageKeywordsAuto(); // 키워드 자동 갱신

    } catch (error) {
        if (uploadToast) uploadToast.clear();
        console.error(`[${MODULE_NAME}] Error uploading ZIP:`, error);
        const errorText = error.responseText || '알 수 없는 오류';
        showToast('error', `업로드 중 오류가 발생했습니다. ${errorText}`, '업로드 실패');
    }
}

/**
 * 개별 이미지 파일 업로드
 * @param {File} file 이미지 파일
 * @param {string} label 라벨(키워드)
 * @returns {Promise<boolean>} 업로드 성공 여부
 */
async function handleImageUpload(file, label) {
    const character = getCurrentCharacter();
    if (!character) {
        showToast('error', '선택된 캐릭터가 없습니다.');
        return false;
    }

    const characterName = character.avatar.replace(/\.[^/.]+$/, '');
    const formData = new FormData();
    formData.append('name', characterName);
    formData.append('label', label);
    formData.append('avatar', file);
    formData.append('spriteName', label);

    try {
        // jQuery.ajax 사용 및 headers 제거
        await jQuery.ajax({
            type: 'POST',
            url: '/api/sprites/upload',
            data: formData,
            processData: false,
            contentType: false,
            cache: false
        });

        // 기존 이미지 키워드 목록 가져오기
        const characterAssets = getCharacterAssets(String(this_chid));
        const existingKeywords = characterAssets.imageKeywords || [];

        // 새 키워드가 목록에 없으면 추가
        if (!existingKeywords.includes(label)) {
            existingKeywords.push(label);
            characterAssets.imageKeywords = existingKeywords;
            saveSettingsDebounced();
        }

        return true;

    } catch (error) {
        console.error(`[${MODULE_NAME}] Image upload failed:`, error);
        // 오류 토스트는 setupEventHandlers에서 처리
        return false;
    }
}

/**
 * 이벤트 핸들러 설정
 */
function setupEventHandlers() {
    // 정규식 설정 변경
    $('#character_assets_regex_find').on('change', function() {
        const assets = getCharacterAssets(String(this_chid));
        assets.regexFind = $(this).val();
        saveSettingsDebounced();
        // createOrUpdateRegexScript(String(this_chid)); // 더 이상 호출 안 함
    });

    $('#character_assets_regex_replace').on('change', function() {
        const assets = getCharacterAssets(String(this_chid));
        assets.regexReplace = $(this).val();
        saveSettingsDebounced();
        // createOrUpdateRegexScript(String(this_chid)); // 더 이상 호출 안 함
    });

    // 새로운 정규식 옵션 UI 변경 이벤트
    $('#regex_user_input').on('change', function() {
        const assets = getCharacterAssets(String(this_chid));
        if (!assets.regexOptions) {
            assets.regexOptions = {};
        }
        assets.regexOptions.userInput = $(this).prop('checked');
        saveSettingsDebounced();
        // createOrUpdateRegexScript(String(this_chid)); // 더 이상 호출 안 함
    });

    $('#regex_ai_output').on('change', function() {
        const assets = getCharacterAssets(String(this_chid));
        if (!assets.regexOptions) {
            assets.regexOptions = {};
        }
        assets.regexOptions.aiOutput = $(this).prop('checked');
        saveSettingsDebounced();
        // createOrUpdateRegexScript(String(this_chid)); // 더 이상 호출 안 함
    });

    $('#regex_run_on_edit').on('change', function() {
        const assets = getCharacterAssets(String(this_chid));
        if (!assets.regexOptions) {
            assets.regexOptions = {};
        }
        assets.regexOptions.runOnEdit = $(this).prop('checked');
        saveSettingsDebounced();
        // createOrUpdateRegexScript(String(this_chid)); // 더 이상 호출 안 함
    });

    $('#regex_only_format_display').on('change', function() {
        const assets = getCharacterAssets(String(this_chid));
        if (!assets.regexOptions) {
            assets.regexOptions = {};
        }
        assets.regexOptions.onlyFormatDisplay = $(this).prop('checked');
        saveSettingsDebounced();
        // createOrUpdateRegexScript(String(this_chid)); // 더 이상 호출 안 함
    });

    // 이미지 프롬프트 변경
    $('#character_assets_image_prompt').on('change', function() {
        extension_settings[MODULE_NAME].imagePrompt = $(this).val();
        saveSettingsDebounced();
    });

    // 이미지 프롬프트 초기화
    $('#character_assets_reset_prompt').on('click', function() {
        $('#character_assets_image_prompt').val(DEFAULT_IMAGE_PROMPT);
        extension_settings[MODULE_NAME].imagePrompt = DEFAULT_IMAGE_PROMPT;
        saveSettingsDebounced();
    });

    // 프리셋 선택 드롭다운 변경 이벤트
    $('#prompt_preset_selector').on('change', function() {
        const selectedPresetId = $(this).val();
        if (selectedPresetId) {
            selectPreset(selectedPresetId);
        }
    });

    // 프리셋 저장 버튼
    $('#save_preset_btn').on('click', function() {
        saveCurrentPromptToPreset();
        updatePresetUI();
    });

    // 새 프리셋 버튼
    $('#new_preset_btn').on('click', async function() {
        const name = await callPopup('새 프리셋 이름을 입력하세요:', 'input');
        if (name && name.trim()) {
            await createPreset(name.trim());
            updatePresetUI();
            showToast('success', `"${name.trim()}" 프리셋이 생성되었습니다.`);
        }
    });

    // 프리셋 이름 변경 버튼
    $('#rename_preset_btn').on('click', async function() {
        const preset = getCurrentPreset();
        if (!preset) return;

        if (preset.name === DEFAULT_PRESET_NAME) {
            showToast('error', '기본 프리셋의 이름은 변경할 수 없습니다.');
            return;
        }

        const newName = await callPopup(`"${preset.name}" 프리셋의 새 이름을 입력하세요:`, 'input', preset.name);
        if (newName && newName.trim() && newName !== preset.name) {
            if (renamePreset(preset.id, newName.trim())) {
                updatePresetUI();
                showToast('success', `프리셋 이름이 "${newName.trim()}"(으)로 변경되었습니다.`);
            }
        }
    });

    // 프리셋 삭제 버튼
    $('#delete_preset_btn').on('click', async function() {
        const preset = getCurrentPreset();
        if (!preset) return;

        if (preset.name === DEFAULT_PRESET_NAME) {
            showToast('error', '기본 프리셋은 삭제할 수 없습니다.');
            return;
        }

        const confirmDelete = await callPopup(`정말로 "${preset.name}" 프리셋을 삭제하시겠습니까?`, 'confirm');
        if (confirmDelete === true) {
            if (deletePreset(preset.id)) {
                updatePresetUI();
                updateInterface();
                showToast('success', `"${preset.name}" 프리셋이 삭제되었습니다.`);
            }
        }
    });

    // 플레이스홀더 교체 버튼
    $('#replace_keywords_placeholder_btn').on('click', async function() {
        const character = getCurrentCharacter();
        if (!character) {
            showToast('error', '교체할 키워드를 가져오려면 캐릭터가 선택되어야 합니다.');
            return;
        }
        const characterName = character.avatar.replace(/\.[^/.]+$/, '');
        const assets = await fetchCharacterAssets(characterName);

        if (assets.length === 0) {
            showToast('warning', '현재 캐릭터에 등록된 에셋이 없습니다.');
            return;
        }

        const fileNames = assets.map(asset => {
            const fullFileNameWithQuery = asset.path.split('/').pop();
            return fullFileNameWithQuery.split('?')[0]; // 쿼리 스트링 제거된 파일명
        }).join(', '); // 쉼표와 공백으로 구분

        const currentPrompt = $('#character_assets_image_prompt').val();
        if (currentPrompt.includes('{{img_keywords}}')) {
            const newPrompt = currentPrompt.replace(/\{\{img_keywords\}\}/g, fileNames);
            $('#character_assets_image_prompt').val(newPrompt);
            extension_settings[MODULE_NAME].imagePrompt = newPrompt;
            saveSettingsDebounced();
            showToast('success', '{{img_keywords}} 플레이스홀더가 파일명 목록으로 교체되었습니다.');
        } else {
            showToast('info', '현재 프롬프트에 {{img_keywords}} 플레이스홀더가 없습니다.');
        }
    });

    // 프롬프트 복사 버튼
    $('#copy_image_prompt_btn').on('click', function() {
        const promptText = $('#character_assets_image_prompt').val();
        navigator.clipboard.writeText(promptText).then(() => {
            showToast('success', '이미지 출력 프롬프트가 클립보드에 복사되었습니다.');
        }, (err) => {
            showToast('error', '프롬프트 복사에 실패했습니다.');
            console.error('Clipboard copy failed:', err);
        });
    });

    // 정규식 초기화
    $('#character_assets_reset_regex').on('click', function() {
        $('#character_assets_regex_find').val(DEFAULT_REGEX_FIND);
        $('#character_assets_regex_replace').val(DEFAULT_REGEX_REPLACE);

        // 기본 옵션 체크박스 설정
        $('#regex_user_input').prop('checked', false);
        $('#regex_ai_output').prop('checked', true);
        $('#regex_run_on_edit').prop('checked', true);
        $('#regex_only_format_display').prop('checked', true);

        const assets = getCharacterAssets(String(this_chid));
        assets.regexFind = DEFAULT_REGEX_FIND;
        assets.regexReplace = DEFAULT_REGEX_REPLACE;

        // 옵션 초기화
        assets.regexOptions = {
            userInput: false,
            aiOutput: true,
            runOnEdit: true,
            onlyFormatDisplay: true
        };

        saveSettingsDebounced();
        // createOrUpdateRegexScript(String(this_chid)); // 더 이상 호출 안 함
    });

    // ZIP 파일 업로드
    $('#character_assets_upload_zip').on('change', async function(e) {
        const file = e.target.files[0];
        if (!file) {
            return;
        }

        if (file.type === 'application/zip' || file.type === 'application/x-zip-compressed' || file.name.endsWith('.zip')) {
            await handleZipUpload(file);
        } else {
            showToast('error', 'ZIP 파일만 업로드 가능합니다.', '잘못된 파일 형식');
        }
        // 파일 입력 필드 초기화
        $(this).val('');
    });

    // 개별 이미지 업로드
    $('#character_assets_upload_image').on('change', async function(e) {
        const files = e.target.files;
        if (!files || files.length === 0) {
            return;
        }

        const uploadPromises = [];
        let invalidFiles = [];

        for (const file of files) {
            const fileExt = file.name.split('.').pop().toLowerCase();

            if (!ALLOWED_EXTENSIONS.includes(fileExt)) {
                invalidFiles.push(file.name);
                continue;
            }

            // 파일명에서 키워드 자동 추출 (확장자 제외)
            const label = extractKeywordFromFileName(file.name);

            if (!label) {
                showToast('warning', `파일명에서 키워드를 추출할 수 없습니다: ${file.name}`, '경고');
                continue;
            }

            uploadPromises.push(handleImageUpload(file, label));
        }

        if (invalidFiles.length > 0) {
            showToast('error', `지원되지 않는 파일 형식: ${invalidFiles.join(', ')}`, '잘못된 파일 형식');
        }

        if (uploadPromises.length > 0) {
            const uploadToast = showToast('info', `${uploadPromises.length}개의 이미지 업로드 중...`, '처리 중', { timeOut: 0, extendedTimeOut: 0 });

            try {
                await Promise.all(uploadPromises);
                if (uploadToast) uploadToast.clear();
                showToast('success', `${uploadPromises.length}개의 이미지가 성공적으로 업로드되었습니다.`, '업로드 완료');
                await loadCharacterAssets();
                await refreshImageKeywordsAuto(); // 키워드 자동 갱신
            } catch (error) {
                if (uploadToast) uploadToast.clear();
                showToast('error', '일부 파일 업로드 중 오류가 발생했습니다.', '업로드 실패');
                console.error('[CHARACTER-ASSETS] Upload error:', error);
                await loadCharacterAssets();
                await refreshImageKeywordsAuto(); // 키워드 자동 갱신
            }
        }

        // 파일 입력 필드 초기화
        $(this).val('');
    });

    // ZIP 파일 업로드 버튼 클릭
    $('#character_assets_upload_zip_btn').on('click', function() {
        $('#character_assets_upload_zip').trigger('click');
    });

    // 개별 이미지 업로드 버튼 클릭
    $('#character_assets_upload_image_btn').on('click', function() {
        $('#character_assets_upload_image').attr('multiple', true);
        $('#character_assets_upload_image').trigger('click');
    });

    // '전체 선택' 체크박스 변경 시 모든 키워드 체크박스 상태 변경
    $('#select_all_keywords').off('change').on('change', function() {
        $('.keyword-checkbox').prop('checked', $(this).prop('checked'));
    });

    // '선택 삭제' 버튼 이벤트 핸들러 연결
    $('#delete_selected_keywords').off('click').on('click', async function() {
        const selectedKeywords = [];
        $('.keyword-checkbox:checked').each(function() {
            selectedKeywords.push($(this).data('keyword'));
        });

        if (selectedKeywords.length === 0) {
            showToast('warning', '삭제할 키워드를 선택해주세요.');
            return;
        }

        const confirmDelete = await callPopup(
            `선택된 ${selectedKeywords.length}개의 키워드와 관련된 모든 파일을 삭제하시겠습니까?<br><br><b>${selectedKeywords.join(', ')}</b>`,
            'confirm',
            undefined,
            { okButton: '삭제' }
        );

        if (confirmDelete === true) {
            const deletePromises = [];
            const character = getCurrentCharacter();
            const characterName = character?.avatar?.replace(/\.[^/.]+$/, '');

            if (!characterName) {
                showToast('error', '캐릭터 정보를 가져올 수 없습니다.');
                return;
            }

            showToast('info', '선택된 키워드 삭제 중...', '처리 중', { timeOut: 0, extendedTimeOut: 0 });

            // 각 선택된 키워드에 대해 파일 목록 가져와서 삭제 요청 생성
            const assets = await fetchCharacterAssets(characterName);
            selectedKeywords.forEach(keyword => {
                const filesToDelete = assets.filter(asset => asset.label === keyword);
                filesToDelete.forEach(asset => {
                    const fullFileNameWithQuery = asset.path.split('/').pop();
                    const fileName = fullFileNameWithQuery.split('?')[0];
                    const spriteName = fileName.split('.').slice(0, -1).join('.');

                    deletePromises.push(jQuery.ajax({
                        type: 'POST',
                        url: '/api/sprites/delete',
                        data: JSON.stringify({
                            name: characterName,
                            label: keyword,
                            spriteName: spriteName
                        }),
                        contentType: 'application/json',
                        cache: false
                    }));
                });
            });

            try {
                await Promise.all(deletePromises);
                showToast('success', '선택된 키워드가 모두 삭제되었습니다.');
                await loadCharacterAssets(); // 목록 새로고침
                await refreshImageKeywordsAuto(); // 키워드 자동 갱신
                $('#select_all_keywords').prop('checked', false); // 전체 선택 해제
            } catch (error) {
                console.error(`[${MODULE_NAME}] Error deleting selected assets:`, error);
                const errorText = error.responseText || '알 수 없는 오류';
                showToast('error', `선택된 키워드 삭제 중 오류 발생: ${errorText}`, '삭제 실패');
            }
        }
    });

    // 프리셋 내보내기 버튼 클릭
    $('#export_presets_btn').off('click').on('click', function() {
        exportPresets();
    });

    // 프리셋 불러오기 버튼 클릭
    $('#import_presets_btn').off('click').on('click', function() {
        $('#import_presets_input').trigger('click');
    });

    // 프리셋 파일 선택 시
    $('#import_presets_input').off('change').on('change', function(e) {
        if (e.target.files.length > 0) {
            importPresets(e.target.files[0]);
        }
        $(this).val(''); // 입력 필드 초기화
    });

    // 갤러리 열기 버튼 클릭
    $('#open_asset_gallery_btn').off('click').on('click', function() {
        openGallery();
    });

    // 갤러리 닫기 버튼 클릭
    $('.asset-modal-close').off('click').on('click', function(e) {
        e.stopPropagation(); // 이벤트 전파 방지
        $('#asset_gallery_modal').hide();
    });

    // 갤러리 배경 클릭 시 닫기
    $('#asset_gallery_modal').off('click').on('click', function(e) {
        if (e.target === this) {
            $(this).hide();
        }
    });

    // 갤러리 검색 필터
    $('#gallery_search').off('input').on('input', function() {
        const filterValue = $(this).val().toLowerCase();
        $('.asset-gallery-item').each(function() {
            const keyword = $(this).data('keyword').toLowerCase();
            const filename = $(this).data('filename').toLowerCase();
            if (keyword.includes(filterValue) || filename.includes(filterValue)) {
                $(this).show();
            } else {
                $(this).hide();
            }
        });
    });

    // 그리드 크기 변경
    $('#gallery_grid_size').off('change').on('change', function() {
        applyGridSize($(this).val());
    });
}

/**
 * 갤러리 그리드 크기 적용
 * @param {string} size 그리드 크기 ('small', 'medium', 'large')
 */
function applyGridSize(size) {
    const container = $('#asset_gallery_container');

    // 기존 클래스 제거
    container.removeClass('grid-small grid-medium grid-large');

    // 새 클래스 추가
    container.addClass(`grid-${size}`);

    // 설정 저장
    if (!extension_settings[MODULE_NAME].gallerySettings) {
        extension_settings[MODULE_NAME].gallerySettings = {};
    }
    extension_settings[MODULE_NAME].gallerySettings.gridSize = size;
    saveSettingsDebounced();
}

/**
 * 메시지 전송 전 이벤트 핸들러 (img_keywords 치환용)
 * @param {object} data 이벤트 데이터
 */
function onMessageSend(data) {
    const character = getCurrentCharacter();
    if (!character || !isCharacterAssetsEnabled(String(this_chid))) {
        return;
    }

    // 여기서 replacePlaceholders는 {{img_keywords}} 만 처리 (만약 필요하다면)
    data.message = replacePlaceholders(data.message, String(this_chid));
}

/**
 * 이미지 확장 초기화
 */
async function initializeExtension() {
    // 기본 설정값 초기화
    initializeSettings();

    // HTML 로드 및 삽입
    const html = await $.get(`/scripts/extensions/third-party/${MODULE_NAME}/templates/settings.html`);
    $('#extensions_settings').append(html);

    // 설정 패널에 이벤트 핸들러 연결
    setupEventHandlers();

    // UI 초기화
    $('#character_assets_image_prompt').val(extension_settings[MODULE_NAME].imagePrompt || DEFAULT_IMAGE_PROMPT);
    updatePresetUI();

    // 현재 캐릭터 에셋 로드
    onCharacterChanged();

    // 이벤트 리스너 등록
    eventSource.on(event_types.CHAT_CHANGED, onCharacterChanged);
    eventSource.on(event_types.MESSAGE_SENT, onMessageSend);
    eventSource.on(event_types.MESSAGE_SWIPED, onMessageSend);

    // 정규식 스타일 다운로드 이벤트 리스너
    document.addEventListener('download-regex-style', (event) => {
        downloadImageStyleRegex(event.detail.styleId);
    });

    document.addEventListener('download-all-regex-styles', () => {
        downloadAllImageStyleRegex();
    });

    // 전역 매크로 시스템에 플레이스홀더 등록
    if (typeof MacrosParser !== 'undefined' && MacrosParser.registerMacro) {
        // {{img_inprompt}} 매크로 등록 - 이미지 출력 프롬프트 전체 반환
        MacrosParser.registerMacro('img_inprompt', () => extension_settings[MODULE_NAME].imagePrompt || DEFAULT_IMAGE_PROMPT, '캐릭터 에셋 이미지 출력 프롬프트');

        // {{img_keywords}} 매크로 등록 - 현재 캐릭터의 이미지 키워드 목록 반환
        MacrosParser.registerMacro('img_keywords', () => {
            const assets = getCharacterAssets(String(this_chid));
            return assets && Array.isArray(assets.imageKeywords) ? assets.imageKeywords.join(', ') : '';
        }, '현재 캐릭터의 이미지 키워드 목록');

        // {{img_keywords_autogen}} 매크로 등록 - 자동 갱신되는 이미지 파일명 목록
        MacrosParser.registerMacro('img_keywords_autogen', () => autoGeneratedKeywords, '자동 갱신되는 캐릭터 에셋 파일명 목록');

        // {{charkey}} 매크로 등록 - 현재 캐릭터의 실제 폴더명
        MacrosParser.registerMacro('charkey', () => {
            const character = getCurrentCharacter();
            if (!character || !character.avatar) {
                return '';
            }
            // avatar에서 확장자를 제거하여 실제 폴더명 반환
            return character.avatar.replace(/\.[^/.]+$/, '');
        }, '현재 캐릭터의 실제 저장 폴더명');

        console.log(`[${MODULE_NAME}] 매크로 등록 완료: img_inprompt, img_keywords, img_keywords_autogen, charkey`);
    }

    // 초기 키워드 자동 갱신
    await refreshImageKeywordsAuto();

    console.debug(`[${MODULE_NAME}] 확장 초기화 완료`);
}

/**
 * / 명령어: 에셋 업로드
 */
function uploadAssetCommand(args, url) {
    if (!url) {
        showToast('error', '업로드할 이미지 URL을 입력해주세요.');
        return '';
    }

    const character = getCurrentCharacter();
    if (!character) {
        showToast('error', '선택된 캐릭터가 없습니다.');
        return '';
    }

    const label = args.label;
    if (!label) {
        showToast('error', '키워드(라벨)를 지정해주세요.');
        return '';
    }

    // URL에서 이미지 다운로드 후 업로드
    fetch(url)
        .then(response => response.blob())
        .then(blob => {
            const file = new File([blob], `${label}.png`, { type: 'image/png' });
            handleImageUpload(file, label);
        })
        .catch(error => {
            console.error(`[${MODULE_NAME}] Error downloading image:`, error);
            showToast('error', '이미지 다운로드 중 오류가 발생했습니다.');
        });

    return `키워드 "${label}"로 이미지 업로드를 시작합니다...`;
}

/**
 * 프리셋 내보내기
 */
function exportPresets() {
    try {
        const currentPreset = getCurrentPreset();
        if (!currentPreset) {
            showToast('warning', '내보낼 프리셋이 없습니다.');
            return;
        }

        // 파일 다운로드 - 현재 선택된 프리셋만 포함
        const json = JSON.stringify([currentPreset], null, 2);
        const filename = `character-assets-preset_${currentPreset.name}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        download(json, filename, 'application/json');

        showToast('success', `"${currentPreset.name}" 프리셋이 성공적으로 내보내졌습니다.`);
    } catch (error) {
        console.error(`[${MODULE_NAME}] Error exporting preset:`, error);
        showToast('error', '프리셋 내보내기 중 오류가 발생했습니다.');
    }
}

/**
 * 프리셋 불러오기
 * @param {File} file JSON 파일
 */
async function importPresets(file) {
    try {
        const fileContent = await getFileText(file);
        let importedPresets;

        try {
            importedPresets = JSON.parse(fileContent);
        } catch (parseError) {
            showToast('error', '잘못된 JSON 형식입니다.', '파싱 오류');
            return;
        }

        // 배열 형식 검증
        if (!Array.isArray(importedPresets)) {
            showToast('error', '프리셋 데이터가 배열 형식이 아닙니다.', '형식 오류');
            return;
        }

        // 각 프리셋 검증
        const validPresets = importedPresets.filter(preset => {
            return preset && typeof preset === 'object' &&
                   preset.id && typeof preset.id === 'string' &&
                   preset.name && typeof preset.name === 'string' &&
                   preset.prompt && typeof preset.prompt === 'string';
        });

        if (validPresets.length === 0) {
            showToast('error', '유효한 프리셋이 없습니다.', '형식 오류');
            return;
        }

        // 사용자 확인 (덮어쓰기/추가 선택)
        const confirmImport = await callPopup(
            `${validPresets.length}개의 프리셋을 불러왔습니다. 어떻게 처리하시겠습니까?`,
            'confirm',
            {
                okButton: '추가',
                cancelButton: '덮어쓰기',
                extraButton: '취소',
            }
        );

        if (confirmImport === 'extra') {
            return; // 취소
        }

        const currentPresets = extension_settings[MODULE_NAME].presets || [];
        const currentPresetId = getCurrentPresetId();

        if (confirmImport === true) { // 추가
            // ID 중복 검사
            const existingIds = new Set(currentPresets.map(p => p.id));
            // 이름 중복 처리
            validPresets.forEach(preset => {
                if (existingIds.has(preset.id)) {
                    preset.id = uuidv4(); // 새 ID 생성
                }

                // 이름 중복 검사
                let uniqueName = preset.name;
                let counter = 1;
                while (currentPresets.some(p => p.name === uniqueName)) {
                    uniqueName = `${preset.name} (${counter})`;
                    counter++;
                }
                preset.name = uniqueName;
            });

            // 프리셋 추가
            extension_settings[MODULE_NAME].presets = [...currentPresets, ...validPresets];
        } else { // 덮어쓰기
            extension_settings[MODULE_NAME].presets = validPresets;

            // 현재 선택된 프리셋이 삭제된 경우, 첫 번째 프리셋으로 전환
            if (!validPresets.some(p => p.id === currentPresetId) && validPresets.length > 0) {
                extension_settings[MODULE_NAME].currentPresetId = validPresets[0].id;
                extension_settings[MODULE_NAME].imagePrompt = validPresets[0].prompt;
            }
        }

        // 설정 저장 및 UI 업데이트
        saveSettingsDebounced();
        updatePresetUI();
        $('#character_assets_image_prompt').val(extension_settings[MODULE_NAME].imagePrompt || DEFAULT_IMAGE_PROMPT);

        showToast('success', `${validPresets.length}개의 프리셋이 성공적으로 불러와졌습니다.`);
    } catch (error) {
        console.error(`[${MODULE_NAME}] Error importing presets:`, error);
        showToast('error', '프리셋 불러오기 중 오류가 발생했습니다.');
    }
}

/**
 * 갤러리 모달 열기
 */
async function openGallery() {
    const character = getCurrentCharacter();
    if (!character) {
        showToast('error', '선택된 캐릭터가 없습니다.');
        return;
    }

    try {
        // 갤러리 컨테이너 비우기
        const galleryContainer = $('#asset_gallery_container');
        galleryContainer.empty();

        // 로딩 메시지 표시
        galleryContainer.html('<div class="loading-message">에셋 로딩 중...</div>');

        // 모달 표시
        $('#asset_gallery_modal').show();

        // 캐릭터 에셋 불러오기
        const characterName = character.avatar.replace(/\.[^/.]+$/, '');
        const assets = await fetchCharacterAssets(characterName);

        // 컨테이너 비우기
        galleryContainer.empty();

        if (assets.length === 0) {
            galleryContainer.html('<div class="no-assets-message">에셋이 없습니다.</div>');
            return;
        }

        // 갤러리 아이템 생성
        assets.forEach(asset => {
            const keyword = asset.label;
            const fullFileNameWithQuery = asset.path.split('/').pop();
            const fileName = fullFileNameWithQuery.split('?')[0];
            const assetPath = asset.path;

            const galleryItem = $(`
                <div class="asset-gallery-item" data-keyword="${keyword}" data-filename="${fileName}">
                    <div class="asset-gallery-img-container">
                        <img class="asset-gallery-img" src="${assetPath}" alt="${fileName}" onerror="this.src='../img/notfound.webp'">
                    </div>
                    <div class="asset-gallery-caption">${keyword}: ${fileName}</div>
                    <div class="asset-gallery-actions">
                        <i class="fa-solid fa-eye asset-gallery-action asset-view-action" title="원본 크기로 보기"></i>
                        <i class="fa-solid fa-trash asset-gallery-action asset-delete-action" title="삭제"></i>
                    </div>
                </div>
            `);

            galleryContainer.append(galleryItem);
        });

        // 갤러리 아이템 이벤트 연결
        // 이미지 클릭 - 원본 크기로 보기
        $('.asset-view-action').on('click', function(e) {
            e.stopPropagation(); // 이벤트 전파 방지
            const imgSrc = $(this).closest('.asset-gallery-item').find('.asset-gallery-img').attr('src');
            showPreviewImage(imgSrc);
        });

        // 이미지 삭제
        $('.asset-delete-action').on('click', async function(e) {
            e.stopPropagation(); // 이벤트 전파 방지
            const item = $(this).closest('.asset-gallery-item');
            const keyword = item.data('keyword');
            const fileName = item.data('filename');

            const confirmDelete = await callPopup(`정말로 '${fileName}' 파일을 삭제하시겠습니까?`, 'confirm', undefined, { okButton: '삭제' });
            if (confirmDelete === true) {
                await handleDeleteAsset(keyword, fileName);
                item.remove();

                // 모든 이미지가 삭제되었는지 확인
                if ($('.asset-gallery-item').length === 0) {
                    galleryContainer.html('<div class="no-assets-message">에셋이 없습니다.</div>');
                }

                // 에셋 목록 새로고침
                await loadCharacterAssets();
            }
        });

        // 그리드 크기 변경 적용
        applyGridSize($('#gallery_grid_size').val());
    } catch (error) {
        console.error(`[${MODULE_NAME}] Error opening gallery:`, error);
        showToast('error', '갤러리 로딩 중 오류가 발생했습니다.');
    }
}

/**
 * 이미지 원본 크기로 보기
 * @param {string} imgSrc 이미지 URL
 */
function showPreviewImage(imgSrc) {
    // 이미 열려있는 프리뷰 모달 제거
    $('.asset-preview-modal').remove();
    $(document).off('keydown.preview'); // 이전 ESC 리스너 확실히 제거

    // 새 프리뷰 모달 생성
    const previewModal = $(`
        <div class="asset-preview-modal">
            <div class="asset-preview-modal-content">
                <span class="asset-preview-close">&times;</span>
                <img class="asset-preview-image" src="${imgSrc}" alt="원본 이미지">
            </div>
        </div>
    `);

    // 닫기 함수 (중복 방지)
    const closeModal = (e) => {
        if (e) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
        }
        previewModal.remove();
        $(document).off('keydown.preview'); // ESC 키 리스너 제거
        return false;
    };

    // 모달 배경 클릭/터치 시 닫기 (mousedown/touchstart만 사용)
    previewModal.on('mousedown touchstart', function(e) {
        if (e.target === this) {
            closeModal(e);
        }
    });

    // 닫기 버튼 클릭/터치 시 닫기 (mousedown/touchstart만 사용)
    previewModal.find('.asset-preview-close').on('mousedown touchstart', function(e) {
        closeModal(e);
    });

    // 이미지 클릭/터치시 이벤트 전파 중단
    previewModal.find('.asset-preview-image').on('mousedown touchstart click', function(e) {
        e.stopPropagation();
        e.stopImmediatePropagation();
    });

    // 모달 내용 클릭/터치시 이벤트 전파 중단
    previewModal.find('.asset-preview-modal-content').on('mousedown touchstart click', function(e) {
        e.stopPropagation();
        e.stopImmediatePropagation();
    });

    // ESC 키 누를 때 닫기 이벤트 추가
    $(document).on('keydown.preview', function(e) {
        if (e.key === 'Escape') {
            closeModal(e);
        }
    });

    // 페이지 상위에 모달 표시 (body 직접 자식으로)
    $('body').append(previewModal);

    // 기존 모달의 z-index보다 높게 설정
    previewModal.css('z-index', '10000');
}

/**
 * 이미지 스타일 템플릿을 정규식 JSON으로 다운로드
 * @param {string} styleId 스타일 ID
 */
function downloadImageStyleRegex(styleId) {
    const template = IMAGE_STYLE_TEMPLATES.find(t => t.id === styleId);
    if (!template) {
        showToast('error', '스타일을 찾을 수 없습니다.');
        return;
    }

    const regexData = {
        id: uuidv4(),
        scriptName: `character-assets-${styleId}`,
        findRegex: template.find,
        replaceString: template.replace,
        trimStrings: [],
        placement: [2], // AI_OUTPUT
        disabled: false,
        markdownOnly: true,
        promptOnly: false,
        runOnEdit: false,
        substituteRegex: 0,
        minDepth: null,
        maxDepth: null
    };

    const json = JSON.stringify(regexData, null, 4);
    const filename = `character-assets-regex-${styleId}.json`;
    download(json, filename, 'application/json');

    showToast('success', `"${template.name}" 정규식이 다운로드되었습니다.`);
}

/**
 * 모든 이미지 스타일 템플릿을 하나의 파일로 다운로드
 */
function downloadAllImageStyleRegex() {
    const allRegexData = IMAGE_STYLE_TEMPLATES.map(template => ({
        id: uuidv4(),
        scriptName: `character-assets-${template.id}`,
        findRegex: template.find,
        replaceString: template.replace,
        trimStrings: [],
        placement: [2], // AI_OUTPUT
        disabled: false,
        markdownOnly: true,
        promptOnly: false,
        runOnEdit: false,
        substituteRegex: 0,
        minDepth: null,
        maxDepth: null
    }));

    const json = JSON.stringify(allRegexData, null, 4);
    const filename = `character-assets-regex-all-styles.json`;
    download(json, filename, 'application/json');

    showToast('success', '모든 스타일의 정규식이 다운로드되었습니다.');
}

$(document).ready(function() {
    // 확장 초기화
    initializeExtension();

    // 슬래시 명령어 등록
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'assets-upload',
        aliases: ['업로드에셋'],
        callback: uploadAssetCommand,
        namedArgumentList: [
            SlashCommandNamedArgument.fromProps({
                name: 'label',
                description: '이미지에 적용할 키워드(라벨)',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: true
            })
        ],
        unnamedArgumentList: [
            SlashCommandArgument.fromProps({
                description: '업로드할 이미지 URL',
                typeList: [ARGUMENT_TYPE.STRING],
                isRequired: true
            })
        ],
        helpString: '이미지 URL을 통해 캐릭터 에셋을 업로드합니다.'
    }));

    // 이미지 키워드 갱신 명령어 등록
    SlashCommandParser.addCommandObject(SlashCommand.fromProps({
        name: 'refresh-img-keywords',
        aliases: ['키워드갱신', 'refresh_img_keywords'],
        callback: refreshImageKeywordsCommand,
        helpString: '현재 캐릭터의 이미지 키워드를 수동으로 갱신합니다.'
    }));
});
